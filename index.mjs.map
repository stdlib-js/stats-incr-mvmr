{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer' ;\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number' ;\nimport isnan from '@stdlib/math-base-assert-is-nan' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving variance-to-mean ratio (VMR).\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute a variance-to-mean ratio (VMR).\n*\n* -   The difference between the unbiased sample variance in a window \\\\(W_i\\\\) and the unbiased sample variance in a window \\\\(W_{i+1})\\\\) is given by\n*\n*     ```tex\n*     \\Delta s^2 = s_{i+1}^2 - s_{i}^2\n*     ```\n*\n* -   If we multiply both sides by \\\\(N-1\\\\),\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = (N-1)s_{i+1}^2 - (N-1)s_{i}^2\n*     ```\n*\n* -   If we substitute the definition of the unbiased sample variance having the form\n*\n*     ```tex\n*     \\begin{align*}\n*     s^2 &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i^2 - 2\\bar{x}x_i + \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2\\bar{x} \\sum_{i=1}^{N} x_i + \\sum_{i=1}^{N} \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - \\frac{2N\\bar{x}\\sum_{i=1}^{N} x_i}{N} + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2N\\bar{x}^2 + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - N\\bar{x}^2 \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     we return\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = \\biggl(\\sum_{k=1}^N x_k^2 - N\\bar{x}_{i+1}^2 \\biggr) - \\biggl(\\sum_{k=0}^{N-1} x_k^2 - N\\bar{x}_{i}^2 \\biggr)\n*     ```\n*\n* -   This can be further simplified by recognizing that subtracting the sums reduces to \\\\(x_N^2 - x_0^2\\\\); in which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= x_N^2 - x_0^2 - N\\bar{x}_{i+1}^2 + N\\bar{x}_{i}^2 \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1}^2 - \\bar{x}_{i}^2) \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1} - \\bar{x}_{i})(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* -   Recognizing that the difference of means can be expressed\n*\n*     ```tex\n*     \\bar{x}_{i+1} - \\bar{x}_i = \\frac{1}{N} \\biggl( \\sum_{k=1}^N x_k - \\sum_{k=0}^{N-1} x_k \\biggr) = \\frac{x_N - x_0}{N}\n*     ```\n*\n*     and substituting into the equation above\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = x_N^2 - x_0^2 - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     ```\n*\n* -   Rearranging terms gives us the update equation for the unbiased sample variance\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= (x_N - x_0)(x_N + x_0) - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     &= (x_N - x_0)(x_N + x_0 - \\bar{x}_{i+1} - \\bar{x}_{i}) \\\\\n*     &= (x_N - x_0)(x_N - \\bar{x}_{i+1} + x_0 - \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [mean] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmvmr( 3 );\n*\n* var F = accumulator();\n* // returns null\n*\n* F = accumulator( 2.0 );\n* // returns 0.0\n*\n* F = accumulator( 1.0 );\n* // returns ~0.33\n*\n* F = accumulator( 3.0 );\n* // returns 0.5\n*\n* F = accumulator( 7.0 );\n* // returns ~2.55\n*\n* F = accumulator();\n* // returns ~2.55\n*\n* @example\n* var accumulator = incrmvmr( 3, 2.0 );\n*/\nfunction incrmvmr( W, mean ) {\n\tvar delta;\n\tvar buf;\n\tvar tmp;\n\tvar M2;\n\tvar mu;\n\tvar d1;\n\tvar d2;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( format( '0eZ8T', W ) );\n\t}\n\tbuf = new Array( W );\n\tn = W - 1;\n\tM2 = 0.0;\n\ti = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( mean ) ) {\n\t\t\tthrow new TypeError( format( '0eZA8', mean ) );\n\t\t}\n\t\tmu = mean;\n\t\treturn accumulator2;\n\t}\n\tmu = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated accumulated value. If not provided a value, the accumulator function returns the current accumulated value.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} accumulated value or null\n\t*/\n\tfunction accumulator1( x ) {\n\t\tvar k;\n\t\tvar v;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn ( isnan( M2 ) ) ? NaN : 0.0/mu;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn ( M2/(N-1) ) / mu;\n\t\t\t}\n\t\t\treturn ( M2/n ) / mu;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tmu = NaN;\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tmu += delta / N;\n\t\t\tM2 += delta * (x - mu);\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0 / mu;\n\t\t\t}\n\t\t\treturn ( M2/(N-1) ) / mu;\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\treturn M2 / mu;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tN = 1;\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tv = buf[ k ];\n\t\t\t\t\tif ( isnan( v ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tmu = NaN;\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdelta = v - mu;\n\t\t\t\t\tmu += delta / N;\n\t\t\t\t\tM2 += delta * (v - mu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tdelta = x - tmp;\n\t\t\td1 = tmp - mu;\n\t\t\tmu += delta / W;\n\t\t\td2 = x - mu;\n\t\t\tM2 += delta * (d1 + d2);\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\n\t\treturn ( M2/n ) / mu;\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated accumulated value. If not provided a value, the accumulator function returns the current accumulated value.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} accumulated value or null\n\t*/\n\tfunction accumulator2( x ) {\n\t\tvar k;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn ( M2/N ) / mu;\n\t\t\t}\n\t\t\treturn ( M2/W ) / mu;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tM2 += delta * delta;\n\t\t\treturn ( M2/N ) / mu;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tif ( isnan( buf[ k ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tdelta = buf[ k ] - mu;\n\t\t\t\t\tM2 += delta * delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tM2 += ( x-tmp ) * ( x-mu + tmp-mu );\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\n\t\treturn ( M2/W ) / mu;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default incrmvmr;\n"],"names":["incrmvmr","W","mean","delta","buf","tmp","M2","mu","N","n","i","isPositiveInteger","TypeError","format","Array","arguments","length","isNumber","accumulator2","accumulator1","x","k","v","isnan","NaN"],"mappings":";;4YAkIA,SAASA,EAAUC,EAAGC,GACrB,IAAIC,EACAC,EACAC,EACAC,EACAC,EAGAC,EACAC,EACAC,EACJ,IAAMC,EAAmBV,GACxB,MAAM,IAAIW,UAAWC,EAAQ,QAASZ,IAOvC,GALAG,EAAM,IAAIU,MAAOb,GACjBQ,EAAIR,EAAI,EACRK,EAAK,EACLI,GAAK,EACLF,EAAI,EACCO,UAAUC,OAAS,EAAI,CAC3B,IAAMC,EAAUf,GACf,MAAM,IAAIU,UAAWC,EAAQ,QAASX,IAGvC,OADAK,EAAKL,EACEgB,EAGR,OADAX,EAAK,EACEY,EASP,SAASA,EAAcC,GACtB,IAAIC,EACAC,EACJ,GAA0B,IAArBP,UAAUC,OACd,OAAW,IAANR,EACG,KAEG,IAANA,EACKe,EAAOjB,GAASkB,IAAM,EAAIjB,EAE/BC,EAAIP,EACCK,GAAIE,EAAE,GAAOD,EAEdD,EAAGG,EAAMF,EAMnB,GAHAG,GAAKA,EAAE,GAAKT,EAGPsB,EAAOH,GACXZ,EAAIP,EACJM,EAAKiB,IACLlB,EAAKkB,QAGD,IAAKhB,EAAIP,EAMb,OALAG,EAAKM,GAAMU,EAIXd,IAFAH,EAAQiB,EAAIb,IAEGa,GADfb,GAAMJ,GAFNK,GAAK,KAIM,IAANA,EACG,EAAMD,EAELD,GAAIE,EAAE,GAAOD,EAGlB,GAAW,IAANC,EAGT,OADAF,EAAK,IADLC,EAAKa,GAKD,GAAKG,EAAOnB,EAAKM,KAIrB,IAHAF,EAAI,EACJD,EAAKa,EACLd,EAAK,EACCe,EAAI,EAAGA,EAAIpB,EAAGoB,IACnB,GAAKA,IAAMX,EAAI,CAEd,GADAY,EAAIlB,EAAKiB,GACJE,EAAOD,GAAM,CACjBd,EAAIP,EACJM,EAAKiB,IACLlB,EAAKkB,IACL,MAKDlB,IAFAH,EAAQmB,EAAIf,IAEGe,GADff,GAAMJ,GAFNK,GAAK,WAQkB,IAAhBe,EAAOjB,KAChBD,EAAMD,EAAKM,GAKXJ,IAJAH,EAAQiB,EAAIf,IACPA,EAAME,GAENa,GADLb,GAAMJ,EAAQF,MAOf,OAFAG,EAAKM,GAAMU,EAEFd,EAAGG,EAAMF,EAUnB,SAASW,EAAcE,GACtB,IAAIC,EACJ,GAA0B,IAArBN,UAAUC,OACd,OAAW,IAANR,EACG,KAEHA,EAAIP,EACCK,EAAGE,EAAMD,EAEVD,EAAGL,EAAMM,EAMnB,GAHAG,GAAKA,EAAE,GAAKT,EAGPsB,EAAOH,GACXZ,EAAIP,EACJK,EAAKkB,QAGD,IAAKhB,EAAIP,EAKb,OAJAG,EAAKM,GAAMU,GAGXd,IADAH,EAAQiB,EAAIb,GACEJ,IAFdK,GAAK,GAGaD,EAGd,GAAKgB,EAAOnB,EAAKM,KAErB,IADAJ,EAAK,EACCe,EAAI,EAAGA,EAAIpB,EAAGoB,IACnB,GAAKA,IAAMX,EAAI,CACd,GAAKa,EAAOnB,EAAKiB,IAAQ,CACxBb,EAAIP,EACJK,EAAKkB,IACL,MAEDrB,EAAQC,EAAKiB,GAAMd,EACnBD,GAAMH,EAAQA,QAKS,IAAhBoB,EAAOjB,KAChBD,EAAMD,EAAKM,GACXJ,IAAQc,EAAEf,IAAUe,EAAEb,EAAKF,EAAIE,IAKhC,OAFAH,EAAKM,GAAMU,EAEFd,EAAGL,EAAMM"}